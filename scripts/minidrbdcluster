#!/usr/bin/env python2

import configparser
import json
import os
import re
import signal
import subprocess

DRBDADM_OPEN_FAILED_RE = re.compile(
    'open\\((.*)\\) failed: No such file or directory'
)
MAY_PROMOT_RE = re.compile(
    '(?:exists|change) resource name:((?:\\w|-)+) '
    '(?:\\w+\\:\\w+ )*may_promote:(yes|no) promotion_score:(?:\\d+)'
)
PEER_ROLE_RE = re.compile(
    '(?:exists|change) connection name:((?:\\w|-)+) peer-node-id:(?:\\d+) '
    'conn-name:((?:\\w|-)+) (?:\\w+\\:(?:\\w|-)+ )*(?:connection:(\\w+) )?'
    '(?:\\w+\\:(?:\\w|-)+ )*role:(Primary|Secondary|Unknown)'
)
HAVE_QUORUM_RE = re.compile(
    '(?:exists|change) device name:((?:\\w|-)+) '
    '(?:\\w+\\:(?:\\w|-|/)+ )*quorum:(yes|no)'
)


class SigHupException(Exception):
    pass


class Connection:
    __slots__ = ('name', 'role', 'status')

    def __init__(self, name):
        self.name = name
        self.role = 'Unknown'
        self.status = 'Unknown'

    # TODO: str

class Status:
    __slots__ = ('connections', 'may_promote', 'has_quorum')

    def __init__(self):
        self.connections = dict()
        self.may_promote = False
        self.has_quorum = False

    # TODO: str

def sig_handler(sig, frame):
    raise SigHupException(
        'Received signal ' + str(sig) +
        ' on line ' + str(frame.f_lineno) +
        ' in ' + frame.f_code.co_filename
    )


def call_systemd(operation, service):
    verbose = operation in ('start', 'stop')
    if verbose:
        print('Trying to %s %s' % (operation, service))
    r = os.system('systemctl %s %s' % (operation, service))
    if verbose:
        print('%s for %s %s' % (
            'success' if r == 0 else 'failure', operation, service
        ))
    return r == 0


def ensure_systemd_started(service):
    args = ['systemctl', 'is-active', '--quiet', service]

    proc = subprocess.Popen(args)
    proc.wait()
    if not proc.returncode:
        return True  # Already active.

    return call_systemd('start', service)


def show_status(services, status):
    print('status:')
    for systemd_unit in services:
        call_systemd('status', systemd_unit)
    for res_name in status:
        print('%s is %s' % (res_name, status[res_name]))


def clean_up(services):
    print('exiting:')
    for systemd_unit in reversed(services):
        call_systemd('stop', systemd_unit)


def get_systemd_units(systemd_units_str):
    systemd_units = []
    for systemd_unit in systemd_units_str.split(','):
        systemd_unit = systemd_unit.strip()
        if systemd_unit:
            systemd_units.append(systemd_unit)
    return systemd_units


def process_drbd_events(events2, resources, status):
    line = events2.stdout.readline()
    m = MAY_PROMOT_RE.match(line)
    if m:
        res_name, may_promote = m.groups()
        if res_name in resources:
            cur_status = status[res_name]
            cur_status.may_promote = (may_promote == 'yes')
            if cur_status.may_promote:
                for connection in cur_status.connections.values():
                    connection.status = 'Unknown'

    m = PEER_ROLE_RE.match(line)
    if m:
        res_name, conn_name, conn_status, role = m.groups()
        if res_name in resources:
            cur_status = status[res_name]
            if conn_name not in cur_status.connections:
                cur_status.connections[conn_name] = Connection(conn_name)
            connection = cur_status.connections[conn_name]
            connection.role = role
            connection.status = conn_status or 'Connected'

    m = HAVE_QUORUM_RE.match(line)
    if m:
        res_name, has_quorum = m.groups()
        if res_name in resources:
            status[res_name].has_quorum = has_quorum == 'yes'

def active_drbd_volume(res_name):
    retry = True
    args = ['drbdadm', 'adjust', res_name]
    while True:
        proc = subprocess.Popen(args, stderr=subprocess.PIPE)
        _, stderr = proc.communicate()
        if not proc.returncode:
            return  # Success. \o/

        if not retry:
            break

        m = DRBDADM_OPEN_FAILED_RE.match(stderr)
        if m and subprocess.call(['lvchange', '-ay', m.groups()[0]]) == 0:
            retry = False
        else:
            break

    print('Failed to execute `{}`: {}'.format(args, stderr))


def get_resource_conf(res_name):
    args = ['drbdsetup', 'show', res_name, '--json']
    proc = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (stdout, stderr) = proc.communicate()
    if proc.returncode:
        print('Failed to execute `{}`: {}'.format(args, stderr))
        return

    try:
        conf = json.loads(stdout)
        if not conf:
            print('JSON conf of `{}` is empty.'.format(res_name))
            return
        return conf
    except Exception as e:
        print('Failed to parse JSON conf of `{}`: {}'.format(res_name, e))


def stop_resource(resource, services, message):
    systemd_units_str = resource['systemd-units']
    systemd_units = get_systemd_units(systemd_units_str)
    to_stop = [x for x in systemd_units if x in services]
    if to_stop and message:
        print(message)
    for systemd_unit in reversed(to_stop):
        r = call_systemd('stop', systemd_unit)
        if r:
            services.remove(systemd_unit)


def process_resource(name, resource, status, services):
    # A. We don't have the quorum => stop services.
    if not status.has_quorum:
        print('Can\'t process {}, waiting for quorum...'.format(name))
        stop_resource(resource, services, 'Lost quorum on {}!'.format(name))
        return

    # B. Can't promote, nothing to do.
    if not status.may_promote:
        print('Can\'t promote {}.'.format(name))
        return

    # C. We have the quorum but we can't get connection count (bad config?).
    conf = get_resource_conf(name)
    if not conf:
        stop_resource(resource, services, None)
        return

    try:
        connection_count = len(conf[0]['connections'])
    except Exception as e:
        stop_resource(resource, services, 'Failed to get connection count of {}.'.format(name))
        return
    # TODO: Detect new connections.

    # D. Specific case, only two nodes and quorum disabled.
    if connection_count == 1:
        if len(status.connections) != connection_count:
            print('Current connection count is bad: {}. Expected: {}.'.format(
                len(status.connections), connection_count)
            )
            return
        for connection in status.connections.values():
            if connection.status != 'Connected':
                # Can be a simple reconnection or a split brain.
                print('Bad status of {}: {}.'.format(connection.name, connection.status))
                return

    # E. We can start!
    systemd_units_str = resource['systemd-units']
    for systemd_unit in get_systemd_units(systemd_units_str):
        if not ensure_systemd_started(systemd_unit):
            break
        if systemd_unit not in services:
            services.append(systemd_unit)


def main():
    services = []
    status = dict()
    config = configparser.ConfigParser()
    config.read('/etc/minidrbdcluster.ini')
    resources = config._sections
    if not resources:
        raise Exception(
            'No resources to watch, maybe /etc/minidrbdcluster.ini missing'
        )
    print('Managing DRBD resources: %s' % (' '.join(resources)))
    for res_name in resources:
        status[res_name] = Status()
        active_drbd_volume(res_name)

    signal.signal(signal.SIGHUP, sig_handler)

    print('Starting process...')
    events2 = subprocess.Popen(
        ['drbdsetup', 'events2'], stdout=subprocess.PIPE
    )
    run = True
    while run:
        try:
            process_drbd_events(events2, resources, status)
            for res_name in resources:
                process_resource(res_name, resources[res_name], status[res_name], services)
        except KeyboardInterrupt:
            run = False
        except SigHupException:
            show_status(services, status)

    clean_up(services)


if __name__ == '__main__':
    main()
